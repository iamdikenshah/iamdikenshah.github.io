<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<title>iOS Interview Questions & Answers — Diken Shah</title>
	<meta name="description"
		content="Comprehensive iOS interview questions and answers across beginner, intermediate, and advanced levels — covering Swift, memory management, concurrency, architecture, and more.">
	<meta name="author" content="Diken Shah">
	<link rel="canonical" href="https://iamdikenshah.github.io/blog/ios-interview-questions.html">

	<!-- Open Graph -->
	<meta property="og:title" content="iOS Interview Questions & Answers — Diken Shah">
	<meta property="og:description" content="Comprehensive iOS interview Q&A across beginner, intermediate, and advanced levels.">
	<meta property="og:type" content="article">
	<meta property="og:url" content="https://iamdikenshah.github.io/blog/ios-interview-questions.html">

	<!-- Favicon -->
	<link rel="icon" href="../images/favicon.ico" type="image/x-icon">

	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Poppins:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
		integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
		crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="stylesheet" href="../css/open-iconic-bootstrap.min.css">
	<link rel="stylesheet" href="../css/aos.css">
	<link rel="stylesheet" href="../css/style.css">

	<style>
		.qa-section-label {
			display: inline-block;
			padding: 6px 20px;
			border-radius: 50px;
			font-size: 13px;
			font-weight: 700;
			letter-spacing: 1px;
			text-transform: uppercase;
			margin-bottom: 28px;
		}
		.level-beginner { background: #d1fae5; color: #065f46; }
		.level-intermediate { background: #dbeafe; color: #1e40af; }
		.level-advanced { background: #ede9fe; color: #5b21b6; }

		.qa-item {
			border: 1px solid #e2e8f0;
			border-radius: 12px;
			margin-bottom: 20px;
			overflow: hidden;
		}
		.qa-question {
			background: #f8f9fa;
			padding: 18px 22px;
			font-weight: 600;
			font-size: 15px;
			color: #2d3748;
			cursor: pointer;
			display: flex;
			align-items: flex-start;
			gap: 12px;
			border: none;
			width: 100%;
			text-align: left;
			transition: background 0.2s;
		}
		.qa-question:hover { background: #edf2f7; }
		.qa-question-number {
			flex-shrink: 0;
			width: 28px;
			height: 28px;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 12px;
			font-weight: 700;
			color: white;
			margin-top: 1px;
		}
		.beginner-num { background: #10b981; }
		.intermediate-num { background: #3b82f6; }
		.advanced-num { background: #8b5cf6; }

		.qa-answer {
			padding: 0 22px 0 62px;
			max-height: 0;
			overflow: hidden;
			transition: max-height 0.4s ease, padding 0.3s ease;
		}
		.qa-answer.open {
			max-height: 2000px;
			padding: 0 22px 20px 62px;
		}
		.qa-answer p, .qa-answer ul, .qa-answer ol {
			margin-bottom: 12px;
			font-size: 14.5px;
			color: #4a5568;
			line-height: 1.7;
		}
		.qa-answer ul, .qa-answer ol { padding-left: 20px; }
		.qa-answer pre {
			background: #1a202c;
			color: #e2e8f0;
			padding: 16px 18px;
			border-radius: 8px;
			font-size: 13px;
			overflow-x: auto;
			margin-bottom: 14px;
		}
		.qa-toggle-icon {
			margin-left: auto;
			flex-shrink: 0;
			transition: transform 0.3s;
			color: #a0aec0;
			font-size: 13px;
		}
		.qa-toggle-icon.rotated { transform: rotate(180deg); }
		.level-divider {
			border: none;
			border-top: 2px dashed #e2e8f0;
			margin: 48px 0;
		}
		.quick-stats {
			display: flex;
			gap: 16px;
			flex-wrap: wrap;
			margin-bottom: 32px;
		}
		.quick-stat {
			flex: 1;
			min-width: 100px;
			background: #f8f9fa;
			border: 1px solid #e2e8f0;
			border-radius: 10px;
			padding: 14px;
			text-align: center;
		}
		.quick-stat-value { font-size: 22px; font-weight: 800; color: #007ea7; }
		.quick-stat-label { font-size: 12px; color: #718096; margin-top: 2px; }
	</style>
</head>

<body>
	<!-- Navbar -->
	<nav class="navbar navbar-expand-lg navbar-light ftco_navbar ftco-navbar-light site-navbar-target" id="ftco-navbar">
		<div class="container">
			<a class="navbar-brand" href="../index.html"><span class="brand-highlight">D</span>iken</a>
			<button class="navbar-toggler js-fh5co-nav-toggle fh5co-nav-toggle" type="button" data-toggle="collapse"
				data-target="#ftco-nav" aria-controls="ftco-nav" aria-expanded="false" aria-label="Toggle navigation">
				<span class="oi oi-menu"></span> Menu
			</button>
			<div class="collapse navbar-collapse" id="ftco-nav">
				<ul class="navbar-nav nav ml-auto">
					<li class="nav-item"><a href="../index.html#home-section" class="nav-link"><span>Home</span></a></li>
					<li class="nav-item"><a href="../index.html#about-section" class="nav-link"><span>About</span></a></li>
					<li class="nav-item"><a href="../index.html#services-section" class="nav-link"><span>Expertise</span></a></li>
					<li class="nav-item"><a href="../index.html#skills-section" class="nav-link"><span>Skills</span></a></li>
					<li class="nav-item"><a href="../index.html#resume-section" class="nav-link"><span>Experience</span></a></li>
					<li class="nav-item"><a href="../index.html#projects-section" class="nav-link"><span>Projects</span></a></li>
					<li class="nav-item"><a href="../index.html#blog-section" class="nav-link"><span>Blog</span></a></li>
					<li class="nav-item"><a href="../index.html#contact-section" class="nav-link"><span>Contact</span></a></li>
				</ul>
			</div>
		</div>
	</nav>

	<!-- Blog Post -->
	<main>
		<article class="blog-post-page">
			<!-- Blog Header -->
			<div class="blog-post-header">
				<div class="container">
					<a href="../index.html#blog-section" class="blog-back-link"><i class="fas fa-arrow-left"></i> Back to Blog</a>
					<div class="blog-post-meta-top">
						<span class="blog-post-category">iOS Development</span>
						<span class="blog-post-date"><i class="fas fa-calendar-alt"></i> February 18, 2026</span>
						<span class="blog-post-reading-time"><i class="fas fa-clock"></i> 20 min read</span>
					</div>
					<h1 class="blog-post-title">iOS Interview Questions & Answers</h1>
					<p class="blog-post-subtitle">A comprehensive guide covering Beginner, Intermediate, and Advanced iOS interview questions — from Swift basics and memory management to concurrency, architecture patterns, and performance optimization.</p>
				</div>
			</div>

			<!-- Blog Content -->
			<div class="blog-post-content">
				<div class="container">
					<div class="row justify-content-center">
						<div class="col-lg-8">

							<p>Whether you're preparing for your first iOS role or interviewing for a senior architect position, this guide has you covered. I've compiled the questions I've been asked — and the ones I ask — across 13+ years of iOS development. Click any question to reveal the answer.</p>

							<div class="quick-stats">
								<div class="quick-stat">
									<div class="quick-stat-value">10</div>
									<div class="quick-stat-label">Beginner Q&A</div>
								</div>
								<div class="quick-stat">
									<div class="quick-stat-value">10</div>
									<div class="quick-stat-label">Intermediate Q&A</div>
								</div>
								<div class="quick-stat">
									<div class="quick-stat-value">10</div>
									<div class="quick-stat-label">Advanced Q&A</div>
								</div>
								<div class="quick-stat">
									<div class="quick-stat-value">30</div>
									<div class="quick-stat-label">Total Questions</div>
								</div>
							</div>

							<!-- ─── BEGINNER ─── -->
							<span class="qa-section-label level-beginner"><i class="fas fa-seedling" style="margin-right:6px"></i>Beginner Level</span>

							<!-- Q1 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number beginner-num">1</span>
									What is the difference between <code>var</code> and <code>let</code> in Swift?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p><code>let</code> declares a <strong>constant</strong> — its value cannot be changed after assignment. <code>var</code> declares a <strong>variable</strong> — its value can be reassigned.</p>
									<pre><code>let name = "Diken"     // constant — cannot reassign
var age = 30           // variable — can reassign
age = 31               // ✅ valid
// name = "Other"      // ❌ compiler error</code></pre>
									<p>Best practice: always prefer <code>let</code>. Use <code>var</code> only when mutation is genuinely needed. This makes the intent clear and helps the compiler optimise.</p>
								</div>
							</div>

							<!-- Q2 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number beginner-num">2</span>
									What is an Optional in Swift and why does it exist?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>An <strong>Optional</strong> is a type that can hold either a value or <code>nil</code>  (absence of value). In Swift, non-optional types are guaranteed to always have a value — this forces you to explicitly handle the "no value" case, preventing null pointer crashes that are common in Objective-C and other languages.</p>
									<pre><code>var username: String? = nil   // Optional — can be nil
var city: String = "Ahmedabad" // Non-optional — always has a value

// Safe unwrapping with if let
if let name = username {
    print("Hello, \(name)")
} else {
    print("No username set")
}

// Nil coalescing — provide a default
let display = username ?? "Guest"</code></pre>
									<p><strong>Force unwrapping</strong> (<code>username!</code>) is dangerous — it crashes if the value is nil. Use it only when you are 100% certain a value exists.</p>
								</div>
							</div>

							<!-- Q3 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number beginner-num">3</span>
									What is the difference between a <code>struct</code> and a <code>class</code> in Swift?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>The core difference is <strong>value type vs reference type</strong>:</p>
									<ul>
										<li><strong>struct</strong> — value type. When copied, a new independent copy is made.</li>
										<li><strong>class</strong> — reference type. When assigned or passed, multiple variables can point to the same instance.</li>
									</ul>
									<pre><code>struct Point { var x: Int; var y: Int }
var a = Point(x: 0, y: 0)
var b = a       // b is a COPY
b.x = 10
print(a.x)      // 0 — a unchanged

class Counter { var count = 0 }
let c1 = Counter()
let c2 = c1     // c2 points to the SAME object
c2.count = 10
print(c1.count) // 10 — c1 is affected</code></pre>
									<p><strong>Key practical differences:</strong> Classes support inheritance; structs do not. Classes have deinitializers (<code>deinit</code>). In Swift, prefer structs by default — use classes when identity semantics or inheritance are needed.</p>
								</div>
							</div>

							<!-- Q4 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number beginner-num">4</span>
									What is the App Delegate and what is its role?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>The <strong>AppDelegate</strong> is the entry point for UIKit-based iOS apps. It conforms to <code>UIApplicationDelegate</code> and is responsible for responding to app-level lifecycle events:</p>
									<ul>
										<li><code>application(_:didFinishLaunchingWithOptions:)</code> — app has launched, set up your initial configuration</li>
										<li><code>applicationDidEnterBackground(_:)</code> — app moved to background</li>
										<li><code>applicationWillEnterForeground(_:)</code> — app is about to come to foreground</li>
										<li><code>applicationWillTerminate(_:)</code> — app is about to be killed</li>
									</ul>
									<p>In iOS 13+, scene-based apps moved most lifecycle handling to <code>SceneDelegate</code>. The AppDelegate now primarily handles app launch and background tasks like push notification registration.</p>
								</div>
							</div>

							<!-- Q5 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number beginner-num">5</span>
									What is AutoLayout and why do we use it?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p><strong>AutoLayout</strong> is a constraint-based layout system that lets you describe the relationships between UI elements. Instead of hardcording frames, you define rules like "this button is always 16 points from the right edge" — and iOS calculates the actual frames at runtime for any screen size.</p>
									<p>We use AutoLayout because iOS devices come in many sizes (iPhone SE to iPad Pro), orientations, and with dynamic text sizes. Hardcoded frames break on different screens. AutoLayout makes layouts adaptive by design.</p>
									<pre><code>// Programmatic AutoLayout with NSLayoutConstraint
button.translatesAutoresizingMaskIntoConstraints = false
NSLayoutConstraint.activate([
    button.centerXAnchor.constraint(equalTo: view.centerXAnchor),
    button.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -20),
    button.widthAnchor.constraint(equalToConstant: 200),
    button.heightAnchor.constraint(equalToConstant: 50)
])</code></pre>
								</div>
							</div>

							<!-- Q6 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number beginner-num">6</span>
									What is a closure in Swift?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>A <strong>closure</strong> is a self-contained block of code that can be passed around and executed later. Closures can capture and store references to variables from the surrounding context — this is called <em>capturing</em>.</p>
									<pre><code>// Basic closure
let greet = { (name: String) -> String in
    return "Hello, \(name)!"
}
print(greet("Diken"))  // "Hello, Diken!"

// Trailing closure syntax (very common in iOS)
let numbers = [3, 1, 4, 1, 5]
let sorted = numbers.sorted { $0 < $1 }

// Capturing values — counter closure
func makeCounter() -> () -> Int {
    var count = 0
    return {
        count += 1   // captures 'count' from outer scope
        return count
    }
}
let counter = makeCounter()
print(counter())  // 1
print(counter())  // 2</code></pre>
									<p>Closures are used extensively in iOS for callbacks, animations, completion handlers, and functional operations like <code>map</code>, <code>filter</code>, and <code>reduce</code>.</p>
								</div>
							</div>

							<!-- Q7 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number beginner-num">7</span>
									What is the difference between <code>UIView</code> and <code>CALayer</code>?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>Every <code>UIView</code> has an underlying <code>CALayer</code> (Core Animation layer). They serve different purposes:</p>
									<ul>
										<li><strong>UIView</strong> — Handles user interaction (touch events), participates in the responder chain, manages layout, and provides a high-level API.</li>
										<li><strong>CALayer</strong> — Handles actual rendering and drawing on screen. Responsible for visual properties like <code>cornerRadius</code>, <code>shadowOpacity</code>, <code>borderWidth</code>, and animations.</li>
									</ul>
									<pre><code>// Modifying a view's layer directly
view.layer.cornerRadius = 12
view.layer.borderWidth = 1
view.layer.borderColor = UIColor.systemBlue.cgColor
view.layer.shadowOpacity = 0.3
view.layer.shadowOffset = CGSize(width: 0, height: 4)</code></pre>
									<p>You use the layer directly for visual effects. You use the view for interaction and layout.</p>
								</div>
							</div>

							<!-- Q8 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number beginner-num">8</span>
									What is a <code>protocol</code> in Swift?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>A <strong>protocol</strong> defines a blueprint of methods, properties, and requirements. Any type (struct, class, enum) that <em>conforms</em> to the protocol must implement those requirements. Protocols are Swift's primary tool for abstraction and polymorphism.</p>
									<pre><code>protocol Drawable {
    var color: String { get }
    func draw()
}

struct Circle: Drawable {
    let color: String
    func draw() { print("Drawing a \(color) circle") }
}

struct Square: Drawable {
    let color: String
    func draw() { print("Drawing a \(color) square") }
}

// Protocol as a type — polymorphism
let shapes: [Drawable] = [Circle(color: "red"), Square(color: "blue")]
shapes.forEach { $0.draw() }</code></pre>
									<p>Protocols are the backbone of iOS frameworks — <code>UITableViewDataSource</code>, <code>Decodable</code>, <code>Equatable</code> are all protocols. In Clean Architecture, repository interfaces are defined as protocols.</p>
								</div>
							</div>

							<!-- Q9 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number beginner-num">9</span>
									What is the difference between <code>frame</code> and <code>bounds</code> in UIKit?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>Both describe a rectangle, but in different coordinate spaces:</p>
									<ul>
										<li><strong>frame</strong> — the view's position and size in its <em>parent's</em> coordinate system. Used to position the view within its superview.</li>
										<li><strong>bounds</strong> — the view's internal coordinate space, starting at (0,0). Used to draw content inside the view.</li>
									</ul>
									<pre><code>let view = UIView(frame: CGRect(x: 50, y: 100, width: 200, height: 100))
print(view.frame)   // (50, 100, 200, 100) — position in parent
print(view.bounds)  // (0, 0, 200, 100) — always starts at 0,0</code></pre>
									<p>When you rotate or transform a view, the <code>frame</code> changes to encompass the rotated view, but the <code>bounds</code> stays the same. When implementing <code>draw(_:)</code>, always work in <code>bounds</code>.</p>
								</div>
							</div>

							<!-- Q10 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number beginner-num">10</span>
									What is <code>UserDefaults</code> and when should you use it?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p><strong>UserDefaults</strong> is a persistent key-value store for storing small, simple user preferences and settings. Data persists across app launches.</p>
									<pre><code>// Writing
UserDefaults.standard.set(true, forKey: "isDarkModeEnabled")
UserDefaults.standard.set("en", forKey: "preferredLanguage")

// Reading
let isDark = UserDefaults.standard.bool(forKey: "isDarkModeEnabled")
let lang = UserDefaults.standard.string(forKey: "preferredLanguage") ?? "en"

// Removing
UserDefaults.standard.removeObject(forKey: "isDarkModeEnabled")</code></pre>
									<p><strong>Use UserDefaults for:</strong> user preferences, app settings, small flags (onboarding shown, notifications enabled).</p>
									<p><strong>Do NOT use for:</strong> sensitive data (use Keychain), large data (use CoreData/files), complex object graphs. UserDefaults is not encrypted — anything stored there is readable.</p>
								</div>
							</div>

							<hr class="level-divider">

							<!-- ─── INTERMEDIATE ─── -->
							<span class="qa-section-label level-intermediate"><i class="fas fa-code" style="margin-right:6px"></i>Intermediate Level</span>

							<!-- Q11 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number intermediate-num">1</span>
									Explain ARC (Automatic Reference Counting) and retain cycles.
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p><strong>ARC</strong> automatically manages memory for class instances by tracking how many references point to each object. When the count reaches zero, the object is deallocated.</p>
									<p>A <strong>retain cycle</strong> occurs when two objects hold strong references to each other, preventing the count from ever reaching zero — causing a memory leak.</p>
									<pre><code>class Parent {
    var child: Child?        // strong reference
}

class Child {
    var parent: Parent?      // strong reference — RETAIN CYCLE!
}

// Fix: make one side weak
class Child {
    weak var parent: Parent? // weak — doesn't increase retain count
}</code></pre>
									<p><strong>Common retain cycles in iOS</strong>: closures capturing <code>self</code> strongly. Fix with <code>[weak self]</code> or <code>[unowned self]</code>:</p>
									<pre><code>// Retain cycle — self is captured strongly
viewModel.onUpdate = { 
    self.tableView.reloadData() // CYCLE if viewModel is owned by self
}

// Fix
viewModel.onUpdate = { [weak self] in
    self?.tableView.reloadData()
}</code></pre>
									<p>Use <code>weak</code> when the reference might become nil. Use <code>unowned</code> when you're sure the referenced object outlives the closure.</p>
								</div>
							</div>

							<!-- Q12 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number intermediate-num">2</span>
									What is the difference between GCD and OperationQueue?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>Both are used for concurrent programming, but at different levels:</p>
									<ul>
										<li><strong>GCD (Grand Central Dispatch)</strong> — low-level C-based API. Simple and lightweight. Best for straightforward async work.</li>
										<li><strong>OperationQueue</strong> — higher-level, built on GCD. Supports operation dependencies, cancellation, priorities, and maximum concurrent operations. Best for complex task scheduling.</li>
									</ul>
									<pre><code>// GCD — simple async work
DispatchQueue.global(qos: .background).async {
    let data = fetchData()
    DispatchQueue.main.async {
        self.updateUI(with: data) // always update UI on main thread
    }
}

// OperationQueue — with dependencies
let fetchOp = BlockOperation { /* fetch data */ }
let processOp = BlockOperation { /* process data */ }
let saveOp = BlockOperation { /* save results */ }

processOp.addDependency(fetchOp)   // process only after fetch
saveOp.addDependency(processOp)    // save only after process

let queue = OperationQueue()
queue.addOperations([fetchOp, processOp, saveOp], waitUntilFinished: false)</code></pre>
									<p>In modern Swift, both are largely superseded by <strong>async/await</strong> with Swift Concurrency, which is more readable and safer.</p>
								</div>
							</div>

							<!-- Q13 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number intermediate-num">3</span>
									What are <code>@escaping</code> and <code>@nonescaping</code> closures?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>A <strong>non-escaping closure</strong> (default) is guaranteed to execute before the function it's passed into returns. The function completes, the closure is done — it doesn't outlive the call stack.</p>
									<p>An <strong>@escaping closure</strong> is stored somewhere (a property, a dictionary) or executed asynchronously — meaning it can be called <em>after</em> the function has already returned.</p>
									<pre><code>// Non-escaping — runs before function returns
func doWork(completion: () -> Void) {
    completion()  // called synchronously — non-escaping by default
}

// @escaping — stored and called later
class NetworkManager {
    var completionHandler: (() -> Void)?

    func fetchData(completion: @escaping () -> Void) {
        // Store the closure — it will outlive this function call
        completionHandler = completion

        URLSession.shared.dataTask(with: url) { _, _, _ in
            DispatchQueue.main.async {
                completion()  // called asynchronously — must be @escaping
            }
        }.resume()
    }
}</code></pre>
									<p>Why does it matter? With <code>@escaping</code>, the compiler requires you to explicitly reference <code>self</code> — a hint that a retain cycle is possible.</p>
								</div>
							</div>

							<!-- Q14 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number intermediate-num">4</span>
									What is the MVVM pattern and how does it work in iOS?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p><strong>MVVM</strong> (Model-View-ViewModel) separates concerns into three components:</p>
									<ul>
										<li><strong>Model</strong> — data and business logic</li>
										<li><strong>View</strong> — UI (UIViewController / SwiftUI View). Passively renders state.</li>
										<li><strong>ViewModel</strong> — transforms Model data into View-ready state. Contains presentation logic. No UIKit imports.</li>
									</ul>
									<pre><code>// Model
struct Article {
    let title: String
    let date: Date
    let readTimeMinutes: Int
}

// ViewModel — transforms model for the View
final class ArticleViewModel: ObservableObject {
    @Published var title: String = ""
    @Published var formattedDate: String = ""
    @Published var readTimeSummary: String = ""

    func configure(with article: Article) {
        title = article.title
        formattedDate = DateFormatter.localizedString(from: article.date,
                                                       dateStyle: .medium,
                                                       timeStyle: .none)
        readTimeSummary = "\(article.readTimeMinutes) min read"
    }
}

// View — just binds to ViewModel state
struct ArticleRow: View {
    @ObservedObject var vm: ArticleViewModel

    var body: some View {
        VStack(alignment: .leading) {
            Text(vm.title).font(.headline)
            HStack {
                Text(vm.formattedDate)
                Text(vm.readTimeSummary)
            }
            .font(.caption).foregroundColor(.secondary)
        }
    }
}</code></pre>
								</div>
							</div>

							<!-- Q15 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number intermediate-num">5</span>
									How does URLSession work and what are its key components?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p><strong>URLSession</strong> is Apple's built-in networking API. Key components:</p>
									<ul>
										<li><strong>URLSession</strong> — manages a group of related network tasks</li>
										<li><strong>URLSessionConfiguration</strong> — defines behaviour (default, ephemeral, background)</li>
										<li><strong>URLSessionTask</strong> — individual request (<code>dataTask</code>, <code>uploadTask</code>, <code>downloadTask</code>)</li>
										<li><strong>URLRequest</strong> — configures a specific request (URL, headers, HTTP method, body)</li>
									</ul>
									<pre><code>// Modern async/await networking
func fetchUser(id: Int) async throws -> User {
    guard let url = URL(string: "https://api.example.com/users/\(id)") else {
        throw URLError(.badURL)
    }

    var request = URLRequest(url: url)
    request.httpMethod = "GET"
    request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

    let (data, response) = try await URLSession.shared.data(for: request)

    guard let http = response as? HTTPURLResponse, http.statusCode == 200 else {
        throw URLError(.badServerResponse)
    }

    return try JSONDecoder().decode(User.self, from: data)
}</code></pre>
									<p>Use <code>.default</code> configuration for standard requests, <code>.ephemeral</code> for private browsing (no cache), and <code>.background</code> for downloads that should continue when the app is in the background.</p>
								</div>
							</div>

							<!-- Q16 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number intermediate-num">6</span>
									What is the difference between <code>@State</code>, <code>@Binding</code>, and <code>@ObservedObject</code> in SwiftUI?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<ul>
										<li><strong>@State</strong> — local state owned by a single view. Simple value types. View re-renders when it changes.</li>
										<li><strong>@Binding</strong> — a reference to state owned by a parent view. Allows a child to read and mutate parent state. Two-way connection.</li>
										<li><strong>@ObservedObject</strong> — for external reference types conforming to <code>ObservableObject</code>. View subscribes to <code>@Published</code> changes.</li>
										<li><strong>@StateObject</strong> — like @ObservedObject, but the view <em>owns</em> the object's lifetime. Use this to create the object; use @ObservedObject when receiving it from outside.</li>
									</ul>
									<pre><code>// @State — local to this view
struct CounterView: View {
    @State private var count = 0

    var body: some View {
        Stepper("Count: \(count)", value: $count) // $count is a Binding
    }
}

// @Binding — parent-owned state
struct ToggleRow: View {
    @Binding var isEnabled: Bool // receives Binding from parent

    var body: some View {
        Toggle("Enabled", isOn: $isEnabled)
    }
}

// @StateObject — view owns the ViewModel
struct HomeView: View {
    @StateObject private var vm = HomeViewModel()
    // ...
}</code></pre>
								</div>
							</div>

							<!-- Q17 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number intermediate-num">7</span>
									How does Codable work in Swift?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p><strong>Codable</strong> is a type alias for <code>Encodable &amp; Decodable</code>. Types conforming to Codable can be automatically serialized to and from JSON (and other formats) without manual parsing.</p>
									<pre><code>struct Product: Codable {
    let id: Int
    let name: String
    let price: Double
    let isAvailable: Bool

    // Custom key mapping (JSON uses snake_case, Swift uses camelCase)
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case price
        case isAvailable = "is_available"
    }
}

// Decode JSON → Swift
let json = """{"id":1,"name":"Widget","price":9.99,"is_available":true}""".data(using: .utf8)!
let product = try JSONDecoder().decode(Product.self, from: json)
print(product.name)  // "Widget"

// Encode Swift → JSON
let encoder = JSONEncoder()
encoder.outputFormatting = .prettyPrinted
let data = try encoder.encode(product)
print(String(data: data, encoding: .utf8)!)</code></pre>
									<p>Use <code>dateDecodingStrategy</code> on <code>JSONDecoder</code> to handle date formats, and <code>keyDecodingStrategy = .convertFromSnakeCase</code> to avoid manual <code>CodingKeys</code> for standard snake_case APIs.</p>
								</div>
							</div>

							<!-- Q18 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number intermediate-num">8</span>
									What is the responder chain in iOS?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>The <strong>responder chain</strong> is how UIKit handles events (touches, motion, remote control, menu actions). When an event occurs, UIKit passes it to the first responder — if that object doesn't handle it, the event is passed up the chain to the next responder.</p>
									<p>The chain flows: <code>UIView → UIViewController → UIWindow → UIApplication → AppDelegate</code></p>
									<pre><code>// First responder — typically the focused text field
textField.becomeFirstResponder()   // become first responder (show keyboard)
textField.resignFirstResponder()   // give up first responder (hide keyboard)

// Sending actions up the responder chain
UIApplication.shared.sendAction(#selector(handleCustomAction), to: nil, from: self, for: nil)
// 'to: nil' means "pass up the chain until someone handles it"</code></pre>
									<p>Understanding the responder chain is critical when debugging why a touch isn't being received, or when implementing custom keyboard shortcuts and menu actions.</p>
								</div>
							</div>

							<!-- Q19 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number intermediate-num">9</span>
									What is dependency injection and why is it important in iOS?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p><strong>Dependency Injection (DI)</strong> means providing an object's dependencies from outside rather than letting the object create them itself. Instead of a ViewModel creating its own NetworkManager, you pass one in.</p>
									<pre><code>// Without DI — tightly coupled, impossible to test
class UserViewModel {
    private let api = NetworkManager()  // creates its own — BAD
    func loadUser() { api.fetchUser() }
}

// With DI — loosely coupled, testable
protocol UserService {
    func fetchUser(id: Int) async throws -> User
}

class UserViewModel {
    private let service: UserService  // injected — can be mocked

    init(service: UserService) {
        self.service = service
    }
}

// Production
let vm = UserViewModel(service: DefaultUserService())

// Test — inject a mock
let vm = UserViewModel(service: MockUserService())
</code></pre>
									<p>DI is the foundation of Clean Architecture and testability. When combined with protocols, it means you can swap real implementations for mocks without changing any business logic.</p>
								</div>
							</div>

							<!-- Q20 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number intermediate-num">10</span>
									What is the difference between <code>async/await</code> and closures for async work?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>Swift's <strong>async/await</strong> (introduced in Swift 5.5) provides a structured, linear way to write asynchronous code. Closures require nesting, manual error handling, and careful memory management.</p>
									<pre><code>// Closure-based — callback hell for sequential tasks
func loadProfile(userId: Int) {
    fetchUser(userId) { result in
        switch result {
        case .success(let user):
            fetchPosts(user.id) { result in
                switch result {
                case .success(let posts):
                    DispatchQueue.main.async {
                        self.update(user: user, posts: posts)
                    }
                case .failure(let error): /* handle */ break
                }
            }
        case .failure(let error): /* handle */ break
        }
    }
}

// async/await — linear, readable, Swift handles thread switching
func loadProfile(userId: Int) async throws {
    let user = try await fetchUser(userId)        // waits here
    let posts = try await fetchPosts(user.id)     // then waits here
    await MainActor.run { update(user: user, posts: posts) }
}</code></pre>
									<p>async/await also composes naturally with Swift Concurrency's structured concurrency (<code>async let</code>, <code>TaskGroup</code>) for running tasks in parallel while maintaining clean, readable code.</p>
								</div>
							</div>

							<hr class="level-divider">

							<!-- ─── ADVANCED ─── -->
							<span class="qa-section-label level-advanced"><i class="fas fa-rocket" style="margin-right:6px"></i>Advanced Level</span>

							<!-- Q21 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number advanced-num">1</span>
									How does Swift's actor model prevent data races?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>An <strong>actor</strong> (Swift 5.5+) is a reference type that protects its mutable state from concurrent access. Only one piece of code can execute on an actor at a time — all accesses are serialised. This eliminates data races at the compiler level without needing manual locks.</p>
									<pre><code>// Without actor — data race if accessed from multiple threads
class BankAccount {
    var balance: Double = 0
    func deposit(_ amount: Double) { balance += amount }  // NOT thread-safe
}

// With actor — thread-safe by design
actor BankAccount {
    var balance: Double = 0

    func deposit(_ amount: Double) {
        balance += amount  // safe — actor serialises access
    }

    func getBalance() -> Double { balance }
}

// Usage — must await actor calls from async context
let account = BankAccount()
await account.deposit(100)
let balance = await account.getBalance()

// @MainActor — special actor that runs on the main thread
@MainActor
class ViewModel: ObservableObject {
    @Published var title = ""  // all access guaranteed on main thread
}</code></pre>
									<p>Actors are the preferred replacement for <code>DispatchQueue.main.async</code> and serial queues when managing shared mutable state in Swift Concurrency.</p>
								</div>
							</div>

							<!-- Q22 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number advanced-num">2</span>
									Explain method dispatch in Swift — static, dynamic, and table dispatch.
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>Method dispatch determines how the runtime decides which implementation to call when invoking a method. It affects performance and polymorphism.</p>
									<ul>
										<li><strong>Static (Direct) Dispatch</strong> — the compiler knows at compile time exactly which method to call. No runtime lookup. Fastest. Used for <code>struct</code> methods, <code>final class</code> methods, and methods with <code>@inline</code>.</li>
										<li><strong>Table Dispatch (Virtual)</strong> — used for class methods and protocol requirements. A vtable (for classes) or witness table (for protocols) is consulted at runtime. Moderate overhead.</li>
										<li><strong>Message Dispatch</strong> — used for <code>@objc</code> methods and <code>dynamic</code>. The Objective-C runtime is used. Most flexible (supports method swizzling) but slowest.</li>
									</ul>
									<pre><code>// Static dispatch — fastest
struct Renderer {
    func render() { /* direct call */ }  // static dispatch
}

// Table dispatch — class methods
class Animal {
    func speak() { print("...") }       // vtable dispatch
}
class Dog: Animal {
    override func speak() { print("Woof") }
}

// Message dispatch — @objc dynamic
class ViewController: UIViewController {
    @objc dynamic func viewTapped() {}  // can be swizzled
}

// Force static dispatch on class methods
final class FastRenderer {
    func render() { }  // static dispatch — can't be overridden
}</code></pre>
									<p>Use <code>final</code> liberally for performance — it enables static dispatch and allows the compiler to inline method calls.</p>
								</div>
							</div>

							<!-- Q23 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number advanced-num">3</span>
									What are Swift property wrappers and give examples of custom ones?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>A <strong>property wrapper</strong> adds a layer of separation between the code that manages how a property is stored and the code that defines the property. SwiftUI's <code>@State</code>, <code>@Binding</code>, <code>@Published</code> are all property wrappers.</p>
									<pre><code>// Custom @Clamped wrapper — constrains value to a range
@propertyWrapper
struct Clamped&lt;T: Comparable&gt; {
    private var value: T
    let range: ClosedRange&lt;T&gt;

    init(initialValue: T, _ range: ClosedRange&lt;T&gt;) {
        self.range = range
        self.value = min(max(initialValue, range.lowerBound), range.upperBound)
    }

    var wrappedValue: T {
        get { value }
        set { value = min(max(newValue, range.lowerBound), range.upperBound) }
    }
}

struct VolumeControl {
    @Clamped(0...100) var volume: Int = 50
}

var control = VolumeControl()
control.volume = 150     // clamped to 100
print(control.volume)    // 100

// Custom @UserDefault wrapper
@propertyWrapper
struct UserDefault&lt;T&gt; {
    let key: String
    let defaultValue: T

    var wrappedValue: T {
        get { UserDefaults.standard.value(forKey: key) as? T ?? defaultValue }
        set { UserDefaults.standard.set(newValue, forKey: key) }
    }
}

struct Settings {
    @UserDefault(key: "username", defaultValue: "Guest")
    var username: String
}</code></pre>
								</div>
							</div>

							<!-- Q24 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number advanced-num">4</span>
									How would you architect offline-first capability in an iOS app?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>Offline-first means the app works fully without a network connection and syncs when connectivity is restored. The architecture pattern is <strong>local-first</strong>:</p>
									<ol>
										<li><strong>Single source of truth: local database</strong> — the UI always reads from CoreData/SQLite/Realm, never directly from the network.</li>
										<li><strong>Background sync</strong> — the network layer writes to the local database; UI observes the database.</li>
										<li><strong>Optimistic updates</strong> — apply changes locally immediately, sync to server in background.</li>
										<li><strong>Conflict resolution</strong> — decide how to handle merge conflicts (last-write-wins, server-wins, manual).</li>
									</ol>
									<pre><code>// Repository pattern with local-first approach
final class ArticleRepository {
    private let localStore: CoreDataArticleStore
    private let remoteAPI: ArticleAPI
    private let syncQueue: OperationQueue

    // UI always reads from local — instant, works offline
    func fetchArticles() -> AnyPublisher&lt;[Article], never&gt; {
        localStore.articlesPublisher()
    }

    // Sync fetches from remote, saves locally, UI auto-updates
    func sync() async {
        guard NetworkMonitor.isConnected else { return }
        do {
            let remoteArticles = try await remoteAPI.fetchAll()
            await localStore.upsert(remoteArticles)
        } catch { /* handle gracefully, no UI disruption */ }
    }

    // Write goes local first, queues remote sync
    func saveArticle(_ article: Article) async {
        await localStore.save(article)
        Task.detached { try? await self.remoteAPI.save(article) }
    }
}</code></pre>
									<p>Key tools: <strong>CoreData</strong> with <code>NSFetchedResultsController</code> or <strong>SwiftData</strong> in iOS 17+, combined with <code>NWPathMonitor</code> to detect connectivity changes.</p>
								</div>
							</div>

							<!-- Q25 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number advanced-num">5</span>
									How do you optimise UITableView/UICollectionView performance for large data sets?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>Performance is critical with large lists. Key optimisations:</p>
									<ul>
										<li><strong>Cell reuse</strong> — always dequeue cells with <code>dequeueReusableCell(withIdentifier:)</code>. Never create new cells for every row.</li>
										<li><strong>Estimated row heights</strong> — setting <code>estimatedRowHeight</code> avoids pre-calculating all heights upfront.</li>
										<li><strong>Async image loading</strong> — never load images on the main thread. Use a cache + background loading pattern.</li>
										<li><strong>Prefetching</strong> — use <code>UITableViewDataSourcePrefetching</code> to load data before cells are needed.</li>
										<li><strong>Diffable Data Source</strong> — use <code>UITableViewDiffableDataSource</code> for efficient, animated updates without calling <code>reloadData()</code>.</li>
										<li><strong>Opaque layers</strong> — set <code>cell.layer.isOpaque = true</code> and avoid transparency in cells.</li>
									</ul>
									<pre><code>// Diffable Data Source — efficient updates
enum Section { case main }

var dataSource: UITableViewDiffableDataSource&lt;Section, Item&gt;!

func setupDataSource() {
    dataSource = UITableViewDiffableDataSource(tableView: tableView) { tv, indexPath, item in
        let cell = tv.dequeueReusableCell(withIdentifier: "Cell", for: indexPath)
        cell.textLabel?.text = item.title
        return cell
    }
}

func applySnapshot(items: [Item]) {
    var snapshot = NSDiffableDataSourceSnapshot&lt;Section, Item&gt;()
    snapshot.appendSections([.main])
    snapshot.appendItems(items)
    dataSource.apply(snapshot, animatingDifferences: true)  // only updates changed rows
}</code></pre>
								</div>
							</div>

							<!-- Q26 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number advanced-num">6</span>
									What is Swift's type system's support for generics and how do you use associated types in protocols?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p><strong>Generics</strong> let you write flexible, reusable functions and types that work with any type while maintaining type safety. <strong>Associated types</strong> are placeholder types in protocols — the concrete type is determined by the conforming type.</p>
									<pre><code>// Generic function — works with any Comparable
func findMax&lt;T: Comparable&gt;(_ array: [T]) -> T? {
    array.max()
}
findMax([3, 1, 4, 1, 5])   // Int
findMax(["z", "a", "m"])   // String

// Protocol with associated type
protocol Repository {
    associatedtype Entity   // placeholder — to be defined by conformer
    associatedtype ID

    func fetch(id: ID) async throws -> Entity
    func save(_ entity: Entity) async throws
    func delete(id: ID) async throws
}

// Conformance defines the associated types
struct UserRepository: Repository {
    typealias Entity = User
    typealias ID = UUID

    func fetch(id: UUID) async throws -> User { /* ... */ return User(...) }
    func save(_ entity: User) async throws { /* ... */ }
    func delete(id: UUID) async throws { /* ... */ }
}

// 'some' keyword — opaque return type (Swift 5.1+)
func makeRepository() -> some Repository {
    UserRepository()  // caller knows it's a Repository, not the concrete type
}</code></pre>
								</div>
							</div>

							<!-- Q27 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number advanced-num">7</span>
									How does the Swift runtime handle memory layout for value types?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>Swift uses <strong>Copy-on-Write (CoW)</strong> for large value types (like <code>Array</code>, <code>Dictionary</code>, <code>String</code>) to avoid the performance cost of copying large buffers on every assignment.</p>
									<p>With CoW, the buffer is only copied when a mutation is made and more than one reference exists. Assignments are cheap (just copy a small struct with a reference to the shared buffer).</p>
									<pre><code>// CoW in action with Array
var a = [1, 2, 3, 4, 5]  // buffer allocated
var b = a                  // NO copy yet — both point to same buffer

b.append(6)                // NOW a copy is made — b gets its own buffer
print(a.count)  // 5
print(b.count)  // 6

// Implementing CoW in your own types
final class Storage&lt;T&gt; {
    var data: [T]
    init(_ data: [T]) { self.data = data }
}

struct MyCollection&lt;T&gt; {
    private var storage: Storage&lt;T&gt;

    mutating func append(_ element: T) {
        // isKnownUniquelyReferenced — the CoW mechanism
        if !isKnownUniquelyReferenced(&amp;storage) {
            storage = Storage(storage.data)  // copy only when needed
        }
        storage.data.append(element)
    }
}</code></pre>
									<p>Understanding CoW helps you write performant Swift and avoid accidentally triggering unnecessary copies in performance-sensitive code paths.</p>
								</div>
							</div>

							<!-- Q28 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number advanced-num">8</span>
									How would you implement a thread-safe cache in Swift?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>A thread-safe cache can be implemented multiple ways. Two idiomatic Swift approaches:</p>
									<pre><code>// Approach 1: Actor-based cache (Swift Concurrency)
actor ImageCache {
    private var cache: [URL: UIImage] = [:]

    func image(for url: URL) -> UIImage? {
        cache[url]
    }

    func store(_ image: UIImage, for url: URL) {
        cache[url] = image
    }

    func removeAll() {
        cache.removeAll()
    }
}

// Usage
let cache = ImageCache()
await cache.store(image, for: url)
let cachedImage = await cache.image(for: url)


// Approach 2: Concurrent queue with barrier writes (classic)
final class ThreadSafeCache&lt;Key: Hashable, Value&gt; {
    private var cache: [Key: Value] = [:]
    private let queue = DispatchQueue(label: "cache.queue", attributes: .concurrent)

    func get(key: Key) -> Value? {
        queue.sync { cache[key] }     // concurrent reads — fast
    }

    func set(key: Key, value: Value) {
        queue.async(flags: .barrier) { // exclusive write — safe
            self.cache[key] = value
        }
    }
}</code></pre>
									<p>For image caching in production apps, prefer <code>NSCache</code> (automatically evicts under memory pressure) wrapped with an actor or serial queue for thread safety, rather than a plain <code>Dictionary</code>.</p>
								</div>
							</div>

							<!-- Q29 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number advanced-num">9</span>
									Explain structured concurrency with <code>TaskGroup</code> in Swift.
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p><strong>TaskGroup</strong> allows you to dynamically create and run multiple child tasks concurrently, then collect their results. It's "structured" because child tasks can't outlive their parent — if the parent is cancelled, all children are cancelled too.</p>
									<pre><code>// Fetch multiple users concurrently
func fetchAllUsers(ids: [UUID]) async throws -> [User] {
    try await withThrowingTaskGroup(of: User.self) { group in
        for id in ids {
            group.addTask {
                try await fetchUser(id: id)  // all run concurrently
            }
        }

        var users: [User] = []
        for try await user in group {
            users.append(user)  // collect results as they complete
        }
        return users
    }
}

// async let — simpler for a known fixed number of tasks
func loadDashboard(userId: UUID) async throws -> Dashboard {
    async let profile = fetchProfile(userId)
    async let recentOrders = fetchOrders(userId, limit: 5)
    async let notifications = fetchNotifications(userId)

    // All three requests run in parallel; we await all results here
    return try await Dashboard(
        profile: profile,
        orders: recentOrders,
        notifications: notifications
    )
}</code></pre>
									<p>Structured concurrency eliminates the common bug in callback-based code where forgetting to call a completion handler on one code path causes silent hangs. The compiler enforces that all tasks complete.</p>
								</div>
							</div>

							<!-- Q30 -->
							<div class="qa-item">
								<button class="qa-question" onclick="toggleQA(this)">
									<span class="qa-question-number advanced-num">10</span>
									How do you diagnose and fix memory leaks in an iOS app?
									<i class="fas fa-chevron-down qa-toggle-icon"></i>
								</button>
								<div class="qa-answer">
									<p>Memory leaks are typically caused by retain cycles. Here's a systematic approach to finding and fixing them:</p>
									<p><strong>Tools:</strong></p>
									<ul>
										<li><strong>Xcode Memory Graph Debugger</strong> — pause app, click the memory graph button. Shows all live objects and reference paths. Leaked objects have a purple icon.</li>
										<li><strong>Instruments → Leaks</strong> — records memory allocations over time, highlights leaked memory.</li>
										<li><strong>Instruments → Allocations</strong> — track allocations, identify objects that are never released.</li>
									</ul>
									<p><strong>Common leak patterns and fixes:</strong></p>
									<pre><code>// 1. Closure capturing self — most common
class ViewController: UIViewController {
    var timer: Timer?

    func startTimer() {
        // LEAK: timer holds strong ref to self, self holds timer
        timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in
            self.updateUI()  // strong capture
        }
    }

    // FIX: weak self
    func startTimerFixed() {
        timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [weak self] _ in
            self?.updateUI()
        }
    }
}

// 2. Delegate not declared weak
class TableVC: UIViewController {
    var dataLoader: DataLoader?

    override func viewDidLoad() {
        dataLoader = DataLoader()
        dataLoader?.delegate = self  // if delegate is strong — CYCLE
    }
}

// Fix: always declare delegates as weak
protocol DataLoaderDelegate: AnyObject {}
class DataLoader {
    weak var delegate: DataLoaderDelegate?  // weak — breaks the cycle
}

// 3. Verify dealloc with deinit logging during development
class ViewModel {
    deinit { print("ViewModel deallocated ✅") }
}</code></pre>
									<p>Set <code>deinit</code> logging during development. If <code>deinit</code> is never called after dismissing a screen, you have a leak. Start there before opening Instruments.</p>
								</div>
							</div>

							<p style="margin-top: 32px;">Have a question that's not covered here? Or want to discuss a specific scenario from your interview prep? Feel free to <a href="../index.html#contact-section">reach out</a> — happy to help.</p>

							<!-- Author Card -->
							<div class="blog-author-card">
								<img src="../images/diken_shah_optimized.jpg" alt="Diken Shah" class="blog-author-img" loading="lazy">
								<div class="blog-author-info">
									<h4>Diken Shah</h4>
									<p>Agentic AI Engineer & Mobile Architect with 13+ years of experience. Former iOS lead on banking, healthcare, and e-commerce products. Now building agentic workflows with LangChain and LangGraph.</p>
									<div class="blog-author-social">
										<a href="https://github.com/iamdikenshah" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><i class="fab fa-github"></i></a>
										<a href="https://www.linkedin.com/in/diken-shah/" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn"><i class="fab fa-linkedin-in"></i></a>
										<a href="https://x.com/Diken_Shah" target="_blank" rel="noopener noreferrer" aria-label="X"><i class="fab fa-x-twitter"></i></a>
									</div>
								</div>
							</div>

						</div>
					</div>
				</div>
			</div>
		</article>
	</main>

	<!-- Footer -->
	<footer class="modern-footer">
		<div class="container">
			<div class="footer-bottom">
				<p>&copy; <script>document.write(new Date().getFullYear());</script> Diken Shah. All rights reserved.</p>
				<p class="footer-credit">Designed & Developed with <i class="fas fa-heart footer-heart"></i> by Diken Shah</p>
			</div>
		</div>
	</footer>

	<!-- Back to Top Button -->
	<a href="#" class="back-to-top" id="backToTop" aria-label="Back to top">
		<i class="fas fa-chevron-up"></i>
	</a>

	<script src="../js/jquery.min.js" defer></script>
	<script src="../js/jquery-migrate-3.0.1.min.js" defer></script>
	<script src="../js/popper.min.js" defer></script>
	<script src="../js/bootstrap.min.js" defer></script>
	<script src="../js/jquery.easing.1.3.js" defer></script>
	<script src="../js/jquery.waypoints.min.js" defer></script>
	<script src="../js/aos.js" defer></script>
	<script src="../js/main.js" defer></script>
	<script>
		window.addEventListener('scroll', function () {
			var btn = document.getElementById('backToTop');
			if (window.scrollY > 500) {
				btn.classList.add('show');
			} else {
				btn.classList.remove('show');
			}
		});

		function toggleQA(button) {
			const answer = button.nextElementSibling;
			const icon = button.querySelector('.qa-toggle-icon');
			const isOpen = answer.classList.contains('open');

			// Close all open answers
			document.querySelectorAll('.qa-answer.open').forEach(el => el.classList.remove('open'));
			document.querySelectorAll('.qa-toggle-icon.rotated').forEach(el => el.classList.remove('rotated'));

			// Open clicked one if it was closed
			if (!isOpen) {
				answer.classList.add('open');
				icon.classList.add('rotated');
			}
		}
	</script>
</body>

</html>
